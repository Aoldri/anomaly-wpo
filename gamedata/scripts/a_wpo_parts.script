local parts_list = {}
local ini_parts = itms_manager.ini_parts
GetCost = utils_item.get_item_cost
-- for mechanics, part prices are very high to buy
function utils_item.get_item_cost(obj, profile)
	local sec = obj:section()
	-- printf("profile cfg = %s, sec = %s, parent id %s", profile.cfg, sec, obj:parent() and obj:parent():id() or 0)
	if profile.cfg == "items\\trade\\trade_generic_mechanic.ltx" and parts_list[sec] and obj:parent() and obj:parent():id() ~= 0 then	
		local discount = profile.discount
		local cost_final = discount * parts_list[sec]
		-- printf("Set sale cost of %s to be %s", sec, cost_final)
		return cost_final
	else
		return GetCost(obj, profile)
	end
end


-- inv upgrades


function section_has_parts(sec)
	local psec = ini_sys:r_string_ex(sec,"parent_section") or sec
	local parts = ini_parts:r_string_ex("con_parts_list", psec)
	return parts ~= nil
end 
local function how_much_repair( item_name, item_condition )
	local cost = ini_sys:r_u32(item_name, "cost")
	local class = ini_sys:r_string_ex(item_name, "class")
	local cof = game_difficulties.get_eco_factor("repair") or 1.67
	local wpncoef = (item_name and section_has_parts(item_name)) and 0.4 or 1
	printf("coef is %s", wpncoef)
	return math.floor( cost * (1 - item_condition) * cof * wpncoef ) -- CoP formula, adjusted down further (arti)
end



function inventory_upgrades.can_afford_repair_item( item_name, item_condition )
	local price = how_much_repair( item_name, item_condition )
	if db.actor:money() < price then
		return false
	end
	
	return true
end

function question_repair_item( item_name, item_condition, can, mechanic ) --( string, float, bool, string )
	if(item_name=="pri_a17_gauss_rifle") then
		return game.translate_string("st_gauss_cannot_be_repaired")
	end

	if can then
		local price = how_much_repair( item_name, item_condition )
		if db.actor:money() < price then
			return game.translate_string("st_upgr_cost")..": "..price.." RU\\n"..game.translate_string("ui_inv_not_enought_money")..": "..price-db.actor:money().." RU"
		end
		return game.translate_string("st_upgr_cost").." "..price.." RU. "..game.translate_string("ui_st_inv_repair").."?"
	end
	
	return nil
end

function inventory_upgrades.effect_repair_item( item_name, item_condition)
	local price = how_much_repair( item_name, item_condition )
	db.actor:give_money(-price)

	if (item_name == "wpn_binoc") or (ui_options.get("gameplay/general/mechanic_feature") ~= true) then 
		return
	end

	local item
	local function itr(actor,itm)
		if (itm and itm:section() == item_name and itm:condition() == item_condition) then
			item = itm
			return true
		end
		return false
	end

	db.actor:iterate_inventory(itr,db.actor)

	if (item) then
		local victim = get_speaker()
		if (victim) then
			local damage_factor = 1.0 - clamp(item_condition, 0.0, 1.0)
			inventory_upgrades.lend_item_for_repair(item,victim:section(),6000*damage_factor)
		end
	end
end

function on_game_start()
    
    local prices = ini_file("items\\settings\\part_prices.ltx")
	local part_section = utils_data.collect_section(prices, "wpo_part_prices")
	local n = prices:line_count("wpo_part_prices") or 0

	for i=0, n-1 do
		local result, sec, value = prices:r_line("wpo_part_prices" , i , "", "")
		parts_list[sec] = value
	end
end