
local parts_info = {}

function get_parts_price(prt_name, prt_cond)
	if prt_cond < arti_jamming_mcm.get_config("repairmin") then
		-- replace
		print_dbg("looking for "..prt_name)
		return parts_info[prt_name].price or 8000
	else
		-- repair
		return string.find(prt_name, "_p_") and 500 or 1000
	end
end


function try_replace_part(wpn, table, part, using_tool)
	if (is_barrel(part:section())) then
		news_manager.send_tip(db.actor, game.translate_string("st_news_parts_barrel"), nil, "swiss_knife", 6000)
	elseif (wpn:condition() < REPLACE_THRESHOLD) then
		news_manager.send_tip(db.actor, game.translate_string("st_news_parts_rusty"), nil, "swiss_knife", 6000)
	else
		print_dbg("Replacing %s", part:section())
		local tmp = table[part:section()]
		table[part:section()] = math_floor(part:condition() * 100)
		if tmp == -1 then
			-- part missing, do not swap conditions
			alife_release_id(part:id())
		else
			part:set_condition(tmp/100)
		 end
		item_parts.set_parts_con(wpn:id(), table)
		if (wpn:id() == current_gun) then
			arti_jamming.current_gun_parts_con[part:section()] = table[part:section()]
		end
		-- lose a little condition when replacing parts
		local wpn_cond = math_floor(wpn:condition() * 100)
		if wpn:condition() > 0.6 then
			local range = using_tool and 3 or 13
			wpn:set_condition(wpn:condition() - (math_random(3, 3 + range)/100)) 
		end
		if mag_support.using_mags() and mag_support.is_mag_loaded(wpn) then 
			mag_support.eject_mag(wpn)
		else
			wpn:force_unload_magazine(true)
		end

		news_manager.send_tip(db.actor, game.translate_string("st_news_parts_success"), nil, "swiss_knife", 6000)
	end
end

function field_strip(wpn)
	local chk = ui_options.get("control/general/disassembly_warning")
	if chk and (not d_flag) then
		actor_menu.set_item_news("success", "detail", "st_awr_ctrl")
		return
	end
	
	if wpn and has_parts(wpn) then
		local is_current = wpn:id() == current_gun
		local parts = is_current and current_gun_parts_con or item_parts.get_parts_con(wpn, nil, true)
		for k,v in pairs(parts) do
			if is_part(k) and v ~= -1 and not is_barrel(k) then
				print_dbg("Removing part %s with condition %s", k, v)
				parts[k] = -1
				-- taken from spawn_with_condition to create w. condition
				local part_to_spawn = alife_create(k, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id(), false)
				local data = utils_stpk.get_item_data(part_to_spawn)
				data.condition = v/100
				utils_stpk.set_item_data(data,part_to_spawn)
				alife():register(part_to_spawn)
			end
			if mag_support.using_mags() and mag_support.is_mag_loaded(wpn) then 
				-- wuut_mags.weapon_eject_mag_functor(wpn)
				mag_support.eject_mag(wpn)
			else
				wpn:force_unload_magazine(true)
			end
		end
		item_parts.set_parts_con(wpn:id(), parts)
	else
		-- complain
		news_manager.send_tip(db.actor, game.translate_string("st_field_strip_fail"), nil, "swiss_knife", 6000)
	end
end

function repair_weapon_toolkit(weapon, toolkit_section)
	if string.find(toolkit_section, "toolkit_") and has_parts(weapon) then
		local parts = weapon:id() == current_gun and current_gun_parts_con or item_parts.get_parts_con(weapon, nil, true)
		-- find the lowest condition part, and restore it to 100
		local lowest = nil
		for k,v in pairs(parts) do
			if not lowest or parts[k] < parts[lowest] then
				lowest = k
			end
		end
		if lowest then 
			print_dbg("Replacing part %s in weapon %s", lowest, weapon:section())
			parts[lowest] = 99
			item_parts.set_parts_con(weapon:id(), parts)
		end
		-- item_parts.set_parts_con(weapon:id(), parts)
	end
end
-- what is good part, what is not
local good_breakpoint = 65
function weapon_eval_parts(wpn)
    local sec = ini_sys:r_string_ex(wpn:section(),"parent_section") or wpn:section()
    local parts = ini_parts:r_string_ex("con_parts_list", sec)
	parts = str_explode(parts,",")
	local base_chance = tonumber(arti_jamming_mcm.get_config("newdropschance")) or 50
	local adjusted = base_chance * wpn:condition()
	local parts_data = {}
	parts_data[sec] = math.ceil(wpn:condition())
	for i=1,#parts do
		local part = parts[i]
		local final_chance = math.ceil(adjusted * parts_info[part].weight)
		printf("Part %s has a %s chance to be good.", part, final_chance)
		
		if wpn:condition() > 0.98 then
			printf("Short circuiting")
			parts_data[part] = 99
		elseif math.random(100) < final_chance then
			parts_data[part] = math.random(good_breakpoint, 99)
		else
			parts_data[part] = math.random(1, good_breakpoint - 1)
		end
    end
	se_save_var( wpn:id(), wpn:name(), "parts", parts_data )
end

-- monkey patching
OnRepair = item_repair.UIRepair.OnRepair

function item_repair.UIRepair:OnRepair()
	local obj_1 = self.CC[1]:GetCell_Selected(true)
	repair_weapon_toolkit(obj_1, self.obj:section())
	OnRepair(self)
end

EvaluateParts = item_parts.evaluate_parts

function item_parts.evaluate_parts(obj)
    local sec = obj:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	local id = obj:id()
	local m_con = math.ceil(obj:condition() * 100) -- default condition of the item
	
	local parts = ini_parts:r_string_ex("con_parts_list",sec)
	if parts then
		parts = str_explode(parts,",")
		
		local data = se_load_var(id, obj:name(), "parts")

		-- Savegame compatibility. Recalculate with changed parts
		if data and data[sec] then
			for i=1,#parts do
				if (not data[parts[i]]) then
					empty_table(data)
					break
				end
			end
		end

		-- premature terminate if data exists for weapons
		if data and IsWeapon(obj) and not is_empty(parts)  then return
        elseif has_parts(obj) and arti_jamming_mcm.get_config("newdrops") then
			print_dbg("Alternate evaluation.")
            weapon_eval_parts(obj)
        else
            EvaluateParts(obj)
		end
    end
end

function on_game_start()
    local parts_list = ini_file("items\\settings\\part_prices.ltx")
	local part_section = utils_data.collect_section(parts_list, "wpo_part_prices")
	local n = parts_list:line_count("wpo_part_prices") or 0

	for i=0, n-1 do
		local result, sec, value = parts_list:r_line("wpo_part_prices" , i , "", "")
		local result1, sec1, value1 = parts_list:r_line("wpo_part_weights" , i , "", "")
		print_dbg("Set %s to price %s, weight %s", sec, value, value1)
		parts_info[sec] = {}
		parts_info[sec].price = tonumber(value)
		parts_info[sec].weight = tonumber(value1)
	end
end