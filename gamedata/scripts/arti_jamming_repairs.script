local ini_parts   = itms_manager.ini_parts
local disassembly_chance
local max_con_obj = 0.999
local min_con_obj = 0.001
local spare_parts = utils_data.collect_section(ini_parts,"weapons_spare_parts")
local parts_info = {}
gc = game.translate_string
has_parts = arti_jamming.has_parts
is_part = arti_jamming.is_part
print_dbg = arti_jamming.print_dbg
print_ws = ui_workshop.print_ws
get_config = arti_jamming_mcm.get_config
math_floor = math.floor
current_id = arti_jamming.current_id
reset_cgd = arti_jamming.reset_cgd
has_parts = arti_jamming.has_parts
SetTip = ui_workshop.SetTip

-- also clean parts
function repair_weapon_toolkit(weapon, toolkit_section)
	if  has_parts(weapon) then
		if string.find(toolkit_section, "toolkit_") then
			local parts = item_parts.get_parts_con(weapon, nil, true)
			-- find the lowest condition part, and restore it to 100
			local lowest = nil
			for k,v in pairs(parts) do
				if is_part(k) and (not lowest or v < parts[lowest]) then
					lowest = k
				end
			end
			if lowest then 
				print_dbg("Replacing part %s in weapon %s", lowest, weapon:section())
				parts[lowest] = 99
				item_parts.set_parts_con(weapon:id(), parts)
				if weapon:id() == current_id() then
					reset_cgd()
				end
				news_manager.send_tip(db.actor, gc("st_news_parts_success") .. " " .. ui_item.get_sec_name(lowest), nil, "swiss_knife", 6000)
			end
		elseif string.find(toolkit_section, "cleaning_kit_") then
			local parts = item_parts.get_parts_con(weapon, nil, true)
			local cond_remaining = 40
			local str = gc("st_news_cleaned")
			local parts_cleaned = false
			for k,v in pairs(parts) do
				if is_part(k) and v > 59 and v < 98 and cond_remaining > 0 then
					local to_restore = 99 - v
					if to_restore > cond_remaining then to_restore = cond_remaining end
					parts[k] = v + to_restore
					cond_remaining = cond_remaining - to_restore
					str = str .. "\\n - ".. ui_item.get_sec_name(k)
					parts_cleaned = true
				end
			end
			item_parts.set_parts_con(weapon:id(), parts)
			if weapon:id() == current_id() then
				reset_cgd()
			end
			if parts_cleaned then
				news_manager.send_tip(db.actor,str, nil, "swiss_knife", 6000)
			end
		end
	end
end
-- what is good part, what is not
local good_breakpoint = 60
function weapon_eval_parts(wpn)
    local sec = ini_sys:r_string_ex(wpn:section(),"parent_section") or wpn:section()
    local parts = ini_parts:r_string_ex("con_parts_list", sec)
	parts = str_explode(parts,",")
	local base_chance = tonumber(get_config("newdropschance")) or 50
	local adjusted = base_chance * wpn:condition()
	local parts_data = {}
	parts_data[sec] = math.ceil(wpn:condition() * 100)
	for i=1,#parts do
		local part = parts[i]
		local final_chance = math.ceil(adjusted)-- * parts_info[part].weight)
		print_dbg("Part %s has a %s chance to be good.", part, final_chance)
		
		if wpn:condition() > 0.98 then
			print_dbg("Short circuiting")
			parts_data[part] = 99
		elseif math.random(100) < final_chance then
			parts_data[part] = math.random(good_breakpoint, 99)
		else
			parts_data[part] = math.random(1, good_breakpoint - 1)
		end
    end
	se_save_var( wpn:id(), wpn:name(), "parts", parts_data )
end

-- monkey patching
OnRepair = item_repair.UIRepair.OnRepair

function item_repair.UIRepair:OnRepair()
	local obj_1 = self.CC[1]:GetCell_Selected(true)
	repair_weapon_toolkit(obj_1, self.obj:section())
	OnRepair(self)
end

EvaluateParts = item_parts.evaluate_parts

function item_parts.evaluate_parts(obj)
    local sec = obj:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	local id = obj:id()
	local m_con = math.ceil(obj:condition() * 100) -- default condition of the item
	
	local parts = ini_parts:r_string_ex("con_parts_list",sec)
	if parts then
		parts = str_explode(parts,",")
		
		local data = se_load_var(id, obj:name(), "parts")

		-- Savegame compatibility. Recalculate with changed parts
		if data and data[sec] then
			for i=1,#parts do
				if (not data[parts[i]]) then
					empty_table(data)
					break
				end
			end
		end

		-- premature terminate if data exists for weapons
		if data and IsWeapon(obj) and not is_empty(parts)  then return
        elseif has_parts(obj) and get_config("newdrops") then
			print_dbg("Alternate evaluation.")
            weapon_eval_parts(obj)
        else
            EvaluateParts(obj)
		end
    end
end

local temp_con = {}

-- Prevent weapons with damaged/deformed parts from selling by temp setting condition to 0.
local function on_trade_opened()
	local function check_parts(temp, wpn)
		-- print_dbg("Evaluating item %s", wpn:id())
		if has_parts(wpn) then
			local parts = item_parts.get_parts_con(wpn, nil, true)
			for k,v in pairs(parts) do
				local minpart = get_config("minpart") or 51
				if is_part(k) and v <= minpart then
					print_dbg("Weapon %s (%s) has low quality part. Blacklisting for sale.", wpn:section(), wpn:id())
					temp_con[wpn:id()] = wpn:condition()
					wpn:set_condition(0)
					break
				end
			end
		end
	end
	db.actor:iterate_inventory(check_parts,nil)
	
	local wpn1 = db.actor:item_in_slot(1)
	if wpn1 and (not temp_con[wpn1:id()]) then
		check_parts(nil, wpn1)
	end
	
	local wpn2 = db.actor:item_in_slot(2)
	if wpn2 and (not temp_con[wpn2:id()]) then
		check_parts(nil, wpn2)
	end
	
	local wpn3 = db.actor:item_in_slot(3)
	if wpn3 and (not temp_con[wpn3:id()]) then
		check_parts(nil, wpn3)
	end
end

local function on_trade_closed()
	for k,v in pairs(temp_con) do
		local obj = level.object_by_id(k)
		if obj then
			local p = obj:parent()
			if (p and p:id() == AC_ID) then
				alife_process_item(obj:section(),k, {cond = v})
			end
		end
	end
	temp_con = empty_table(temp_con)
end

-- gotta do this whole ass thing to monkey patch 1 line

-- original functions are local reeeee
local function disassembly_weapon_spare_parts(sec, condition)
	local single_handed = ini_sys:r_float_ex(sec,"single_handed") or 1
	local weight = ini_sys:r_float_ex(sec,"inv_weight") or 2
	local number,finale = 0,0
	
	number = math_floor(weight)
	if (single_handed == 1) then number = 1 end
	
	for i=1,number do
		if (math.random(100) < condition) then
			finale = finale + 1
		end
	end
	
	return finale
end

local function timer_disassembly_weapon(npc_id, result_details, result_conditions, name)

	-- Who is item owner? we must give them the parts
	local npc = npc_id and get_object_by_id(npc_id)
	if (not npc) then
		printf("~ item_parts timer | no owner found")
		return
	end
	
	-- Send messages to the actor
	if #result_details > 0 then
		local parts_text = item_parts.create_disassemble_list(result_details)
		actor_menu.set_item_news('success', 'weapon_ammo', "st_dis_text_7", name, game.translate_string('st_dis_text_9'), parts_text)
	else
		actor_menu.set_item_news('fail', 'weapon', "st_dis_text_2", name)
	end
	
	-- Creating parts in inventory
	for i=1,#result_details do
		if result_conditions[i] and result_conditions[i] > 0 then
			local se_result = alife_create(result_details[i], npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), false)
			local data_result = utils_stpk.get_item_data(se_result)
			data_result.condition = clamp( (result_conditions[i]/100) , min_con_obj , max_con_obj )
			utils_stpk.set_item_data(data_result,se_result)
			alife():register(se_result)
		else
			alife_create_item(result_details[i], npc)
		end
	end
	
	return true
end

DisassemblyWeapon = item_parts.disassembly_weapon

function item_parts.disassembly_weapon(obj, obj_d)
	if has_parts(obj) then
		custom_disassembly_weapon(obj, obj_d)
	else
		DisassemblyWeapon(obj, obj_d)
	end
end

function custom_disassembly_weapon(obj, obj_d)

	-- Defines
	local id = obj:id()
	local se_obj = alife_object(id)
	local sec = obj:section()
	local sec_p = ini_sys:r_string_ex(sec,"parent_section") or sec
	local name = ui_item.get_sec_name(sec)
	local con = obj:condition()
	local parts = item_parts.get_parts_con(obj, nil, true)
	local npc = obj:parent()
	if (not npc) then
		printf("~ item_parts | no owner found for [%s]", obj:name())
		return
	end
	
	local result_details = {}
	local result_conditions = {}
	local get_ammo = {}
	local with_scope = nil
	local delay = actor_effects.is_animations_on() and 3 or 0

	-- Collect attachments
	with_scope = utils_item.has_scope(sec)
	if with_scope then
		with_scope = string.format('_%s', utils_item.has_scope(sec))
		table.insert(result_details, with_scope:sub(2))
		sec = sec:gsub(with_scope, "")
	end	
	if (obj:weapon_scope_status() == 2) and (utils_item.addon_attached(obj,"sc")) then
		local scope_section = utils_data.read_from_ini(nil,sec,"scopes_sect","string",nil)
		local scope = utils_data.read_from_ini(nil,scope_section,"scope_name","string",nil)
		table.insert(result_details, scope)
	end
	if (obj:weapon_silencer_status() == 2) and (utils_item.addon_attached(obj,"sl")) then
		local sil = utils_data.read_from_ini(nil,sec,"silencer_name","string",nil)
		table.insert(result_details, sil)
	end	
	if (obj:weapon_grenadelauncher_status() == 2) and (utils_item.addon_attached(obj,"gl")) then
		local gl = utils_data.read_from_ini(nil,sec,"grenade_launcher_name","string",nil)
		table.insert(result_details, gl)
	end
	
	-- Unload mag and get ammo
	obj:force_unload_magazine(true)
	
	-- Collect weapon parts
	for k,v in pairs(parts) do
		if (k ~= sec_p) and v > 0 and (math.random(100) <= (disassembly_chance + con*100)) then
			local index = #result_details
			result_details[index + 1] = k
			result_conditions[index + 1] = IsItem("part",k) and utils_item.get_cond_static(v) or v
		end
	end
	
	-- Collect weapon spare parts
	for i=1,#spare_parts do
		local num = disassembly_weapon_spare_parts(sec, disassembly_chance/2)
		if (num > 0) then
			for j=1,num do
				table.insert(result_details,spare_parts[i])
			end
		end
	end
	
	-- Collect installed upgrades
	local installed_upgrades = utils_item.get_upgrades_installed(obj)
	local upgr_tools = {}
	
	for i=1,#installed_upgrades do
		local tool = utils_item.get_upgrade_sect_tool(sec, installed_upgrades[i])
		table.insert(upgr_tools,tool)
	end
	
	for i=1,#upgr_tools do
		if math.random(100) < con*50 then
			table.insert(result_details,upgr_tools[i])
		end
	end
	
	-- Release weapon
	alife_release(se_obj)
	
	-- Degrade disassemble tool
	local diss_tools = GetItemList("disassemble")
	local degr_val = diss_tools[obj_d:section()]
	utils_item.degrade( obj_d , degr_val )

	-- Increase Statistic
	game_statistics.increment_statistic("items_disassembled")
	item_parts.clear_parts_con(id)
	
	-- Play animation
	actor_effects.play_item_fx("disassemble_metal_fast")
	
	-- Process
	CreateTimeEvent(0,"delay_disassembly" .. id, delay, timer_disassembly_weapon, npc:id(), result_details, result_conditions, name)
end

-- here we go again
WorkshopReplacePart = ui_workshop.UIWorkshopRepair.ReplacePart

function ui_workshop.UIWorkshopRepair:ReplacePart()
	local obj = self.CC["inventory"]:GetCell_Selected(true)
	if (not obj) then
		return
	end

	if not has_parts(obj) then
		print_dbg("ReplacePart: Not weapon, going through original route")
		WorkshopReplacePart(self)
		return
	end
	local obj_part = self.CC["parts"]:GetCell_Selected(true)
	if not (obj_part and self.selected_btn) then
		return
	end
	
	self.itm_selected[self.selected_btn]:InitTexture("ui_button_inv_t")
		
	print_ws("- UIWorkshopRepair:ReplacePart() | picked replacement part (%s) [%s] - condition: %s", obj_part:id(), obj_part:section(), obj_part:condition())
	
	-- Save the condition of selected part
	local new_part_con = math.ceil(obj_part:condition()*100)
	
	self.new_con[self.selected_btn] = {}
	self.new_con[self.selected_btn].id = obj_part:id()
	self.new_con[self.selected_btn].con = new_part_con
	
	-- Calculate individual condition and update text
	self.btn_repair:Enable(true)
	local tot_con = 0
	local cnt = 0
	local active = 0
	for i=1,6 do
		if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") then
			local t = self.parts[i].con
			if self.new_con[i] then
				t = self.new_con[i].con
				active = active + 1
			end
			local clr = utils_xml.get_color_con(t)
			self.itm_con[i]:SetText(clr .. t .. "%")
			tot_con = tot_con + t --AdjustCon(self.parts[i].sec, t, #self.parts, IsOutfit(self.object))
			cnt = cnt + 1
		end
	end
	
	-- Calculate total condition and update text
	tot_con = clamp(math.ceil(obj:condition() * 100),0,100)
	self.itm_con_r:SetText(tot_con .. "%")
	
	-- Update remaining toolkit count
	-- weapon_parts_overhaul do not consume toolkit charges for swapping parts
	--self:UpdateToolkits(active)
	
	-- Hide part inventory
	self.CC["parts"]:Reset()
	
	utils_obj.play_sound("interface\\items\\inv_items_cloth_" .. tostring(math.random(2,3)))
	
	SetTip("repair_tip_4", nil, nil, nil, true, self.info_text)
	
	-- Reset
	self.selected_btn = nil
	self.highlight_btn = nil
end

WorkshopRepair = ui_workshop.UIWorkshopRepair.Repair
function ui_workshop.UIWorkshopRepair:Repair()
	local obj = self.CC["inventory"]:GetCell_Selected(true)
	if (not obj) then
		return
	end

	if not has_parts(obj) then
		print_dbg("Repair: Not weapon, going through original route")
		WorkshopRepair(self)
		return
	end
	
	local sim = alife()
	local tot_con = 0
	local cnt = 0
	if is_not_empty(self.new_con) then
		for i=1,6 do
			if self.parts[i] and self.parts[i].sec and (self.parts[i].sec ~= "na") then
				if self.new_con[i] and self.new_con[i].id then
					-- weapon_parts_overhaul refund parts
					local temp = self.parts[i].con
					self.parts[i].con = self.new_con[i].con
					print_ws("- UIWorkshopRepair:Repair() | replaced part spotted | part: %s - condition: %s - order: %s - id: %s", self.parts[i].sec, self.new_con[i].con, i, self.new_con[i].id)
					
					-- Release replacement parts
					if temp < 0 then
						alife_release_id(self.new_con[i].id)
					else
						local part = get_object_by_id(self.new_con[i].id)
						part:set_condition(temp/100)
					end
					-- weapon_parts_overhaul end
				end
				
				tot_con = tot_con + self.parts[i].con --AdjustCon(self.parts[i].sec, self.parts[i].con, #self.parts, IsOutfit(self.object))
				cnt = cnt + 1
				print_ws("/ UIWorkshopRepair:Repair() | total condition calculation | part: %s - condition: %s - order: %s - total sum: %s", self.parts[i].sec, self.parts[i].con, i, tot_con)
			end
		end
	else
		print_ws("! UIWorkshopRepair:Repair() | no new parts have been replaced")
		return
	end
	
	-- Discharge tools
	for i=1,#self.toolkit_pick do
		local obj_tool = level.object_by_id(self.toolkit_pick[i])
		if obj_tool then
			utils_item.discharge(obj_tool)
			print_ws("/ UIWorkshopRepair:Repair() | discharged toolkit (%s)", self.toolkit_pick[i])
		else
			printe("!ERROR UIWorkshopRepair:Repair() | can't discharge toolkit with id (%s). Object not found!", self.toolkit_pick[i])
		end
	end
	
	-- Apply condition changes
	local id = obj:id()
	local sec = obj:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	
	local final_con = (cnt > 0) and (clamp(math.ceil(tot_con/cnt),1,100)/100)
	local weapon = level.object_by_id(id)
	if weapon and final_con and (final_con >= 0) and (final_con <= 1) then
		-- weapon_parts_overhaul do not update condition
		if not IsWeapon(weapon) then
			weapon:set_condition(final_con)
			print_ws("- UIWorkshopRepair:Repair() | object with id (%s) is set to a new condition: %s", id, final_con)
		end
	else
		printe("! UIWorkshopRepair:Repair() | object with id (%s) is either not found. Or didn't register new condition (%s)!", id, final_con)
	end
	
	local result_part_tbl = {}
	result_part_tbl[sec] = math.ceil(tot_con/cnt)
	for i=1,#self.parts do
		result_part_tbl[self.parts[i].sec] = self.parts[i].con
	end
	item_parts.set_parts_con(id, result_part_tbl)
	
	for k,v in pairs(result_part_tbl) do
		print_ws("~ UIWorkshopRepair:Repair() | item's new part table [%s] = %s",k,v)
	end
	
	-- Effect
	actor_effects.play_item_fx("craft_dummy")

	self:Close()
end

quality_map = {
	[0] = "broken",
	[1] = "damaged",
	[2] = "worn",
	[3] = "dirty",
}

unique_mapping = {
	["prt_w_gas_tube_9"] = "extractor",
	["prt_w_gas_tube_10"] = "extractor",
	["prt_w_gas_tube_8"] = "ejector",
	["prt_w_gas_tube_2"] = "pump",
	["prt_w_bolt_11"] = "hammers",
	["prt_w_bolt_12"] = "hammers",
	["prt_w_bolt_carrier_8"] = "chock",
	["prt_w_bolt_carrier_9"] = "chock",
}

name_mapping = {
	"spring",
	"bolt_carrier",
	"bolt",
	"gas_tube",
	"barrel",
	"trigger"
}
--Patching ui_item.script
local string_find         = string.find
local math_ceil           = math.ceil
local math_floor          = math.floor
local gc                  = game.translate_string
local clr_r  = utils_xml.get_color("d_red")

function process_part(name, condition)
	if condition > 79 then return "" end
	local severity = condition == -1 and "missing" or math.floor(condition / 20)
	local part_name = ""
	if unique_mapping[name] then
		part_name = unique_mapping[name]
	else
		if not string_find(name, "prt_w") then return "" end
		local i = 1
		while part_name == "" and i < 7 do
			-- print_dbg("it %s, name %s", i, name)
			if string_find(name, name_mapping[i]) then
				part_name = name_mapping[i]
			end
			i = i + 1
		end
	end
	print_dbg("part %s, category %s, sev %s", name, part_name, severity)
	return " " .. clr_r .. gc("st_dot") .. " " .. gc("st_damage_"..severity) .. " " .. gc("st_name_"..part_name) .. "\\n"
end


original_build_desc_header = ui_item.build_desc_header
function ui_item.build_desc_header(obj, sec, str)
	local _str = ""
	local _str2 = original_build_desc_header(obj, sec, str)
	

	if obj and IsWeapon(obj) and not IsAmmo(obj) and arti_jamming.has_parts(obj) then
		local parts = item_parts.get_parts_con(obj, nil, true)
		local display_str = ""
		for k,v in pairs(parts) do
			display_str = display_str .. process_part(k, v)
		end
		if display_str ~= "" then
			display_str =  " " .. clr_r .. gc("st_name_issues") .. "\\n" .. display_str
			_str = _str .. display_str
		end
	end
	_str = _str .. _str2

	return _str
end

function on_game_start()
	
	disassembly_chance  = ini_parts:r_float_ex("settings","disassembly_chance") or 40
	
	RegisterScriptCallback("ActorMenu_on_trade_started",on_trade_opened)
	RegisterScriptCallback("ActorMenu_on_trade_closed",on_trade_closed)
end