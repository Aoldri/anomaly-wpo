local ini_parts   = itms_manager.ini_parts
local parts_info = {}
has_parts = arti_jamming.has_parts
print_dbg = arti_jamming.print_dbg

function repair_weapon_toolkit(weapon, toolkit_section)
	if string.find(toolkit_section, "toolkit_") and has_parts(weapon) then
		local parts = item_parts.get_parts_con(weapon, nil, true)
		-- find the lowest condition part, and restore it to 100
		local lowest = nil
		for k,v in pairs(parts) do
			if not lowest or parts[k] < parts[lowest] then
				lowest = k
			end
		end
		if lowest then 
			print_dbg("Replacing part %s in weapon %s", lowest, weapon:section())
			parts[lowest] = 99
			if weapon:id() == arti_jamming.current_id() then
				arti_jamming.reset_cgd()
			end
			item_parts.set_parts_con(weapon:id(), parts)
		end
	end
end
-- what is good part, what is not
local good_breakpoint = 65
function weapon_eval_parts(wpn)
    local sec = ini_sys:r_string_ex(wpn:section(),"parent_section") or wpn:section()
    local parts = ini_parts:r_string_ex("con_parts_list", sec)
	parts = str_explode(parts,",")
	local base_chance = tonumber(arti_jamming_mcm.get_config("newdropschance")) or 50
	local adjusted = base_chance * wpn:condition()
	local parts_data = {}
	parts_data[sec] = math.ceil(wpn:condition() * 100)
	for i=1,#parts do
		local part = parts[i]
		local final_chance = math.ceil(adjusted)-- * parts_info[part].weight)
		print_dbg("Part %s has a %s chance to be good.", part, final_chance)
		
		if wpn:condition() > 0.98 then
			print_dbg("Short circuiting")
			parts_data[part] = 99
		elseif math.random(100) < final_chance then
			parts_data[part] = math.random(good_breakpoint, 99)
		else
			parts_data[part] = math.random(1, good_breakpoint - 1)
		end
    end
	se_save_var( wpn:id(), wpn:name(), "parts", parts_data )
end

-- monkey patching
OnRepair = item_repair.UIRepair.OnRepair

function item_repair.UIRepair:OnRepair()
	local obj_1 = self.CC[1]:GetCell_Selected(true)
	repair_weapon_toolkit(obj_1, self.obj:section())
	OnRepair(self)
end

EvaluateParts = item_parts.evaluate_parts

function item_parts.evaluate_parts(obj)
    local sec = obj:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	local id = obj:id()
	local m_con = math.ceil(obj:condition() * 100) -- default condition of the item
	
	local parts = ini_parts:r_string_ex("con_parts_list",sec)
	if parts then
		parts = str_explode(parts,",")
		
		local data = se_load_var(id, obj:name(), "parts")

		-- Savegame compatibility. Recalculate with changed parts
		if data and data[sec] then
			for i=1,#parts do
				if (not data[parts[i]]) then
					empty_table(data)
					break
				end
			end
		end

		-- premature terminate if data exists for weapons
		if data and IsWeapon(obj) and not is_empty(parts)  then return
        elseif has_parts(obj) and arti_jamming_mcm.get_config("newdrops") then
			print_dbg("Alternate evaluation.")
            weapon_eval_parts(obj)
        else
            EvaluateParts(obj)
		end
    end
end

function on_game_start()
    local parts_list = ini_file("items\\settings\\part_prices.ltx")
	local part_section = utils_data.collect_section(parts_list, "wpo_part_prices")
	local n = parts_list:line_count("wpo_part_prices") or 0

	for i=0, n-1 do
		local result, sec, value = parts_list:r_line("wpo_part_prices" , i , "", "")
		-- local result1, sec1, value1 = parts_list:r_line("wpo_part_weights" , i , "", "")
		print_dbg("Set %s to price %s, weight %s", sec, value, value1)
		parts_info[sec] = {}
		parts_info[sec].price = tonumber(value)
		-- parts_info[sec].weight = tonumber(value1)
	end
end